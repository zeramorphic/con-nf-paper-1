\documentclass{article}

\usepackage{parskip}
\usepackage{fontspec}
\usepackage{unicode-math}
\newcommand{\diagup}{\char"27CB}
\setmainfont[Path=fonts/,
	UprightFont=*-Regular,
	BoldFont=*-Bold,
	ItalicFont=*-Italic,
	BoldItalicFont=*-BoldItalic,
	]{STIXTwoText}
\setmathfont[Path=fonts/]{STIXTwoMath-Regular}
\setmonofont[Path=fonts/, Scale=MatchLowercase]{FiraCode-Regular}

\usepackage{enumerate}
\usepackage{amsthm}
\usepackage{faktor}
\usepackage{physics}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{relsize}

\usepackage[shortlabels]{enumitem}
\setlist[enumerate,1]{label={(\roman*)}}
\setlist[enumerate,2]{label={(\alph*)}}

\hypersetup{
	colorlinks=true,
	% linkcolor=green!40!black,
}

% mathlib definition
\newcommand{\mdef}[3]{\href{https://leanprover-community.github.io/mathlib4\_docs/Mathlib/#1.html\##2}{\emph{#3}}}
% mathlib lemma
\newcommand{\mlem}[3]{\href{https://leanprover-community.github.io/mathlib4\_docs/Mathlib/#1.html\##2}{#3}}
% core lemma
\newcommand{\corelem}[3]{\href{https://leanprover-community.github.io/mathlib4\_docs/#1.html\##2}{#3}}
% con(nf) definition
\newcommand{\cdef}[3]{\href{https://leanprover-community.github.io/con-nf/doc/ConNF/#1.html\#ConNF.#2}{\emph{#3}}}
% con(nf) lemma
\newcommand{\clem}[3]{\href{https://leanprover-community.github.io/con-nf/doc/ConNF/#1.html\#ConNF.#2}{#3}}

\newcommand{\symmdiff}{\mathrel{\raisebox{1pt}{\( \mathsmaller\triangle \)}}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}{Corollary}[theorem]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\title{New Foundations is consistent}
\author{Sky Wilshaw}
\date{July 2023}

\begin{document}

\maketitle

\section*{Underlying theory}

All of the definitions and theorems that follow have been machine-checked by Lean.

The construction described in this paper takes place in a dependent type theory with:
\begin{itemize}
    \item a proof-irrelevant impredicative universe of propositions called \( \symsf{Prop} \);
    \item predicative universes indexed by \( \omega \), called \( \symsf{Type} = \symsf{Type}\ 0 : \symsf{Type}\ 1 : \dots \);
    \item dependent function types \( \displaystyle \prod_{(x : \alpha)} \beta \) for all types \( \alpha, \beta \), where we denote function application by juxtaposition;
    \item inductive types at each universe;
    \item quotient types, where we denote the quotient of a type \( \alpha \) by the relation \( \sim \) by \( \faktor\alpha\sim \), and denote quotient introduction \( \alpha \to \faktor\alpha\sim \) by \( x \mapsto [x] \);
    \item a \emph{definitional} reduction rule that if \( f \colon \alpha \to \beta \) lifts to \( g \colon \faktor\alpha\sim \to \beta \), then \( g\ [x] = f\ x \).
\end{itemize}
We write \( \symsf{Type}\ u = \symsf{Sort}\ (u + 1) \) and \( \symsf{Prop} = \symsf{Sort}\ 0 \) for conciseness.
We stipulate the following axioms.
\begin{itemize}
    \item propositional extensionality: that if \( p \Leftrightarrow q \) then we have \( p = q \);
    \item a form of the axiom of choice: a function for each type \( \alpha \) that maps a proof that \( \alpha \) is nonempty to some \( x : \alpha \).
\end{itemize}
Lean's dependent type theory satisfies these constraints.
It is known that such a type theory can be modelled in \( \symsf{ZFC} + \qty{\text{there are \( n \) inaccessible cardinals} \mid n < \omega} \) (see \url{https://github.com/digama0/lean-type-theory/releases}).

We model cardinals and ordinals as quotients over a universe of types.
However, apart from this, we make no direct use of higher universes, so the proof can be expected to work with no inaccessible cardinal assumptions.

\section{Definitions and results from mathlib}

In this section, we state a number of well-known definitions and results from the community repository mathlib.
The definitions are included so that the representations of types we use are clear.

\subsection{Sets, groups, and supports}

\begin{definition}
    A \mdef{Init/Set}{Set}{set} of a type \( \alpha \) is a function \( \alpha \to \symsf{Prop} \).
    The type of sets of \( \alpha \) is denoted \( \symsf{Set}\ \alpha \).
\end{definition}
\begin{definition}
    The \mdef{Init/Set}{Set.image}{pointwise image} of a set \( s : \symsf{Set}\ \alpha \) under a function \( f \colon \alpha \to \beta \) is denoted \( f '' s = \qty{y : \beta \mid \exists x \in s, y = f\ x} \).
    The \mdef{Data/Set/Image}{Set.preimage}{preimage} of a set \( t : \symsf{Set}\ \beta \) under \( f \) is denoted \( f^{-1}{}' t = \qty{x : \alpha \mid f\ x \in t} \).
\end{definition}
\begin{definition}
    The \mdef{Order/SymmDiff}{symmDiff}{symmetric difference} of two sets \( s, t : \symsf{Set}\ \alpha \) is defined by \( s \symmdiff t = (s \setminus t) \cup (t \setminus s) \).
\end{definition}
\begin{definition}
    A \mdef{GroupTheory/GroupAction/Defs}{MulAction}{group action} of \( G \) on \( \alpha \) is a function \( G \to \alpha \to \alpha \) denoted by \( \cdot \) such that for all \( x, y : G \), \( a : \alpha \), we have \( (x \cdot y) \cdot a = x \cdot (y \cdot a) \).
\end{definition}
\begin{definition}
    \label{def:supports}
    Let \( G \) be a group that acts on \( \alpha \) and \( \beta \).
    Let \( s \) be a set of \( \alpha \), and let \( b : \beta \).
    We say that \( s \) \mdef{GroupTheory/GroupAction/Support}{MulAction.Supports}{supports} \( b \) if for all \( x \in G \), we have \( x \cdot b = b \) whenever \( x \cdot a = a \) for all \( a \in s \).
\end{definition}
\begin{lemma}
    \label{lem:smul_eq_smul_of_supports}
    Let \( s : \symsf{Set}\ \alpha \) support \( b : \beta \) under actions of \( G \).
    Then for \( x, y \in G \), \( x \cdot b = y \cdot b \) whenever \( x \cdot a = y \cdot a \) for all \( a \in s \).
\end{lemma}
\begin{proof}
    Apply the definition of a support to \( y^{-1} \cdot x \).
\end{proof}

\subsection{Cardinals and ordinals}

\begin{definition}
    An \mdef{Logic/Equiv/Defs}{Equiv}{equivalence} between two types \( \alpha \) and \( \beta \), denoted \( e : \alpha \simeq \beta \), is a pair of functions \( f \colon \alpha \to \beta, g \colon \beta \to \alpha \) that are inverses of each other.
    Equivalences \( e : \alpha \simeq \beta \) naturally coerce to their underlying function \( f : \alpha \to \beta \).
    We use the syntax \( e^{-1} \) to denote the inverse equivalence \( \beta \simeq \alpha \) constructed from \( g \) and \( f \).
\end{definition}
\begin{remark}
    \( (e^{-1})^{-1} = e \) holds definitionally.
\end{remark}
\begin{definition}
    The type of \mdef{Logic/Equiv/Defs}{Equiv.Perm}{permutations} of a type \( \alpha \) is \( \alpha \simeq \alpha \), denoted \( \symsf{Perm}\ \alpha \).
\end{definition}
\begin{definition}
    The type of \mdef{SetTheory/Cardinal/Basic}{Cardinal}{cardinals} is the quotient of \( \symsf{Type} \) by the equivalence relation \( \sim \), where \( \alpha \sim \beta \) if \( \alpha \simeq \beta \) is nonempty.
    We denote the cardinal of a type by \( \#\alpha = [\alpha] \).
\end{definition}
\begin{definition}
    Let \( r : \alpha \to \alpha \to \symsf{Prop} \) be a relation on \( \alpha \).
    We say that \( x : \alpha \) is \mdef{Init/WF}{Acc}{\( r \)-accessible} if for all \( y \) with \( r\ y\ x \), we have that \( y \) is \( r \)-accessible.
    A relation \( r : \alpha \to \alpha \to \symsf{Prop} \) is \mdef{Init/WF}{WellFounded}{well-founded} if every element is accessible.
\end{definition}
\begin{remark}
    This is a constructive form of well-foundedness that behaves very nicely in Lean's type system.
\end{remark}
\begin{theorem}[well-founded recursion]
    Let \( r \) be a well-founded relation on \( \alpha \).
    Let \( C : \alpha \to \symsf{Sort}\ u \) be a motive for the recursion.
    Let \( h \) have type
    \[ \prod_{(x : \alpha)} \qty(\prod_{(y : \alpha)} r\ y\ x \to C\ y) \to C\ x \]
    Then \corelem{Init/WF}{WellFounded.recursion}{we can construct} \( C\ x \) for each \( x : \alpha \).
\end{theorem}
\begin{remark}
    More rigorously, well-founded recursion over \( r \) is a function of type
    \[ \prod_{(C : \alpha \to \symsf{Sort}\ u)} \qty[ \qty(\prod_{(x : \alpha)} \qty(\prod_{(y : \alpha)} r\ y\ x \to C\ y) \to C\ x) \to \prod_{(x : \alpha)} C\ x] \]
    Setting \( u = 0 \) gives well-founded induction.
    This result is obtained by recursion over accessibility, which is an inductive type.
\end{remark}
\begin{definition}
    A relation is a \mdef{Order/RelClasses}{IsWellOrder}{well-order} if it is trichotomous, transitive, and well-founded.
\end{definition}
\begin{definition}
    Let \( \alpha, \beta \) be endowed with relations \( r, s \).
    An equivalence \( e : \alpha \simeq \beta \) is an \mdef{Order/Hom/Basic}{OrderIso}{order isomorphism} if for each \( x, y : \alpha \), we have \( s\ (e\ x)\ (e\ y) \Leftrightarrow r\ x\ y \).
\end{definition}
\begin{definition}
    The type of \mdef{SetTheory/Ordinal/Basic}{Ordinal}{ordinals} is the quotient of the type of well-ordered elements of \( \mathsf{Type} \) by the equivalence relation \( \sim \), where \( \alpha \sim \beta \) if the type of order isomorphisms of \( \alpha \) and \( \beta \) is nonempty.
\end{definition}
Standard properties of cardinals and ordinals are assumed.
\begin{definition}
    A \mdef{Data/Part}{Part}{partial value} of a type \( \alpha \) is a proposition \( p \) and a function \( p \to \alpha \).
    That is, if \( h : p \) is a proof of \( p \), then we can acquire a value \( x : \alpha \).
    The type of such values is denoted \( \symsf{Part}\ \alpha \).
\end{definition}
\begin{definition}
    A \mdef{Data/PFun}{PFun}{partial function} from \( \alpha \) to \( \beta \) is a function from \( \alpha \) to partial values of type \( \beta \).
    The type of such values is denoted \( \alpha \rightdasharrow \beta \).
\end{definition}
We use standard function notation on partial functions.
\begin{remark}
    By propositional extensionality, all empty partial values are equal, and all inhabited partial values with equal values are equal.
\end{remark}

\subsection{Quivers and paths}

\begin{definition}
    A \mdef{Combinatorics/Quiver/Basic}{Quiver}{quiver} on a type \( \alpha \) of vertices assigns to every pair \( x, y : \alpha \) of vertices a type \( \symrm{Hom}(x, y) \) of arrows from \( x \) to \( y \).
\end{definition}
\begin{definition}
    A \mdef{Combinatorics/Quiver/Path}{Quiver.Path}{path} in a quiver between two vertices \( x, y : \alpha \) is a finite list of vertices beginning with \( x \) and ending with \( y \), connecting each pair of adjacent vertices \( a, b \) with an element of \( \symrm{Hom}(a, b) \).
    The type of such paths is written \( x \rightsquigarrow y \).
    The empty path is written \( \varnothing : x \rightsquigarrow x \).
    The \mdef{Combinatorics/Quiver/Path}{Quiver.Path.comp}{composition} of paths \( p : x \rightsquigarrow y, q : y \rightsquigarrow z \) is denoted by \( p \gg q : x \rightsquigarrow z \).
\end{definition}
\begin{remark}
    In mathlib, paths are defined as an inductive type.
    If there is exactly one morphism in a given hom-set \( \symrm{Hom}(a, b) \), it is denoted \( a \to b \).
    We will implicitly convert morphisms \( e : \symrm{Hom}(a, b) \) to their \mdef{Combinatorics/Quiver/Path}{Quiver.Hom.toPath}{corresponding paths} \( e : a \rightsquigarrow b \).
\end{remark}
\begin{definition}
    The \mdef{Combinatorics/Quiver/Path}{Quiver.Path.length}{length} of a path is the number of arrows in that path, or exactly one less than the number of vertices in the list.
\end{definition}

\section{The base type (\texttt{ConNF.BaseType})}

We describe the base level of our construction, as well as all of the other objects that can be described outside the main induction.

\subsection{Model parameters}

\begin{definition}
    \label{def:params}
    A set of \cdef{BaseType/Params}{Params}{model parameters} is
    \begin{itemize}
        \item a type \( \lambda \) endowed with a well-order;
        \item a type \( \kappa \);
        \item a type \( \mu \) endowed with a well-order,
    \end{itemize}
    such that
    \begin{enumerate}
        \item the order type of \( \lambda \) is a nonzero limit ordinal;
        \item the order type of \( \mu \) is the initial ordinal corresponding to the cardinal \( \#\mu \);
        \item \( \#\mu \) is a strong limit cardinal;
        \item \( \#\lambda < \#\kappa < \#\mu \);
        \item the cofinality of the initial ordinal corresponding to \( \#\mu \) is at least \( \#\kappa \).
    \end{enumerate}
\end{definition}
\begin{lemma}
    There exists a set of model parameters.
\end{lemma}
\begin{proof}
    Take \( \lambda = \aleph_0, \kappa = \aleph_1, \mu = \beth_{\omega_1} \).
    These form a set of model parameters by standard properties of cardinals.
\end{proof}
Every definition and theorem following this will implicitly assume a set of model parameters as an additional argument.
\begin{lemma}
    \label{lem:infinite_no_max_model_params}
    \begin{enumerate}
        \item \( \lambda, \kappa, \mu \) are infinite.
        \item \( \lambda \) and \( \mu \) have no maximal element.
    \end{enumerate}
\end{lemma}
\begin{proof}
    \emph{Part (i).}
    \( \lambda \) is a nonzero limit, hence is infinite; condition (iv) then guarantees the result for \( \kappa, \mu \).
    \emph{Part (ii).}
    Initial ordinals have no maximal element.
\end{proof}
\begin{definition}
    The type of \cdef{BaseType/Params}{TypeIndex}{type indices}, denoted \( \lambda^\bot \), is \( \lambda \) together with a symbol denoted \( \bot \).
    The order on \( \lambda^\bot \) places \( \bot \) below all elements of \( \lambda \).
\end{definition}
\begin{lemma}
    \label{lem:mk_typeIndex}
    \( \#\lambda^\bot = \#\lambda \).
\end{lemma}
\begin{proof}
    \( \#\lambda^\bot = \#\lambda + 1 \), and \( \lambda \) is infinite by \cref{lem:infinite_no_max_model_params}(i).
\end{proof}
\begin{lemma}
    \label{lem:typeIndex_wf}
    The type indices are well-ordered.
\end{lemma}
\begin{proof}
    They are clearly linearly ordered, and the relation \( < \) is well-founded.
\end{proof}
\begin{lemma}
    \label{lem:card_Iio_lt}
    For \( x : \mu \), \( \#\qty{y \mid y < x} < \#\mu \) and \( \#\qty{y \mid y \leq x} < \#\mu \).
\end{lemma}
\begin{proof}
    \Cref{def:params} requires that the order type of \( \mu \) is an initial ordinal, so we have \( \#\qty{y \mid y < x} < \#\mu \).
    Then \( \#\qty{y \mid y \leq x} = \#\qty{y \mid y < x} + \#\qty{x} < \#\mu \) as \( \#\mu \) is infinite by \cref{lem:infinite_no_max_model_params}(i).
\end{proof}

\subsection{Smallness}

\begin{definition}
    A set \( s \) of any type \( \alpha \) is called \cdef{BaseType/Small}{Small}{small} if \( \#s < \#\kappa \).
\end{definition}
\begin{remark}
    Note that cardinals are defined on types and not sets: technically we mean that the cardinality of the subtype \( \qty{x : \alpha \mid x \in s} \) is less than \( \#\kappa \).
\end{remark}
\begin{lemma}
    \label{lem:small}
    Let \( f \colon \alpha \to \beta \) and \( s, t : \symsf{Set}\ \alpha \).
    Then,
    \begin{enumerate}
        \item the empty set is small;
        \item singletons are small;
        \item if \( s \subseteq t \) and \( t \) is small then \( s \) is small;
        \item if \( s, t \) are small then \( s \cup t \) is small;
        \item if \( s, t \) are small then \( s \symmdiff t \) is small;
        \item if \( s \) is small then \( s \symmdiff t \) is small if and only if \( t \) is small;
        \item if \( \iota \) is a type with \( \#\iota < \#\kappa \) and \( g \colon \iota \to \mathsf{Set}\ \alpha \) with \( g\ i \) small for each \( i \in \iota \), then \( \bigcup_{i : \iota} g\ i \) is small;
        \item if \( s \) is small then \( f '' s \) is small;
        \item if \( s : \symsf{Set}\ \beta \) is small and \( f \) is injective then \( f^{-1}{}' s \) is small;
        \item if \( t : \symsf{Set}\ \beta \) is small, \( f \) is injective, and \( f '' s \subseteq t \), then \( s \) is small;
        \item if \( f \) is a partial function and \( s \) is small then \( f '' s \) is small.
    \end{enumerate}
\end{lemma}
\begin{proof}
    \begin{enumerate}
        \item \( \#\qty{} = 0 < \aleph_0 \leq \#\kappa \) by \cref{lem:infinite_no_max_model_params}.
        \item \( \#\qty{x} = 1 < \aleph_0 \leq \#\kappa \) by \cref{lem:infinite_no_max_model_params}.
        \item Follows from transitivity.
        \item \( \aleph_0 \leq \#\kappa \) so \( \#\kappa \) is additively closed.
        \item \( s \symmdiff t \subseteq s \cup t \) so done by (iii).
        \item \( s \symmdiff t \symmdiff s = t \) so done by applying (iv) twice.
        \item Follows since \( \kappa \) is regular by \cref{def:params}.
        \item The set \( f '' s \) injects into \( s \) so \( \#(f '' s) \leq \#s \).
        \item The set \( f^{-1}{}' s \) injects into \( s \) if \( f \) is injective.
        \item Follows from (iii) and (ix), as \( f^{-1}{}' (f '' s) = s \) for injective \( f \).
        \item By (viii), the set of partial values of type \( \beta \) in the range of \( f \) is small, by treating \( f \) as a total function \( \alpha \to \symsf{Part}\ \beta \).
        The result then holds by applying (x) to the natural injection \( \iota : \beta \to \symsf{Part}\ \beta \).
    \end{enumerate}
\end{proof}
\begin{definition}
    Sets are \cdef{BaseType/Small}{IsNear}{near} if their symmetric difference is small.
\end{definition}
\begin{lemma}
    \label{lem:near}
    Let \( f \colon \alpha \to \beta \) and \( s, t, u : \symsf{Set}\ \alpha \).
    \begin{enumerate}
        \item \( s \) is near \( s \);
        \item if \( s \) is near \( t \) then \( t \) is near \( s \);
        \item if \( s \) is near \( t \) and \( t \) is near \( u \) then \( s \) is near \( u \);
        \item if \( s \) is near \( t \) then \( f '' s \) is near \( f '' t \);
        \item if \( s \) is small, then \( s \) is near \( t \) if and only if \( t \) is small;
        \item if \( s \) is near \( t \) and \( \#\kappa \leq \#s \), then \( \#\kappa \leq \#t \);
        \item if \( s \) is near \( t \) and \( \#\kappa \leq \#s \), then \( \#\kappa \leq \#(s \cap t) \).
    \end{enumerate}
\end{lemma}
\begin{proof}
    \begin{enumerate}
        \item Follows from \cref{lem:small}(i).
        \item The symmetric difference is commutative.
        \item Follows from \cref{lem:small}(iii, iv) and the fact that \( s \symmdiff u \subseteq (s \symmdiff t) \cup (t \symmdiff u) \).
        \item Follows from \cref{lem:small}(iii, viii) and the fact that \( (f '' s) \symmdiff (f '' t) \subseteq f '' (s \symmdiff t) \).
        \item Follows from \cref{lem:small}(vi).
        \item Suppose not, so \( \#t < \#\kappa \).
        Then as \( s \) is near \( t \), \( s \) is small, contradicting the assumption.
        \item Suppose not, so \( \#(s \cap t) < \#\kappa \).
        As \( s \) is near \( t \), the set \( (s \cup t) \setminus (s \cap t) \) is small.
        But
        \[ \#(s \cup t) \leq \#((s \cup t) \setminus (s \cap t)) + \#(s \cap t) \]
        Both summands on the right-hand side are less than \( \#\kappa \), so \( s \cup t \) must be small.
        But this contradicts the assumption that \( \#\kappa \leq \#s \).
    \end{enumerate}
\end{proof}

\subsection{Litters}

\begin{definition}
    A \cdef{BaseType/Litter}{Litter}{litter} is a triple \( L = \langle \nu, \beta, \gamma \rangle \) with \( \nu : \mu, \beta : \lambda^\bot, \gamma : \lambda \), such that \( \beta \neq \gamma \).
    The type of litters is denoted \( \mathcal L \).
\end{definition}
\begin{lemma}
    \label{lem:mk_litter}
    \( \#\mathcal L = \#\mu \).
\end{lemma}
\begin{proof}
    Note that \( \#(\mu \times \lambda^\bot \times \lambda) = \#\mu \) so \( \#\mathcal L \leq \#\mu \).
    But \( \#\mu \leq \#\mathcal L \) by considering the injection \( \nu \mapsto \langle \nu, \bot, 0 \rangle \), so the result follows by antisymmetry.
\end{proof}

\subsection{Atoms}

\begin{definition}
    The type of \cdef{BaseType/Atom}{Atom}{atoms} is \( \mathcal A = \mathcal L \times \kappa \).
\end{definition}
\begin{lemma}
    \label{lem:mk_atom}
    \( \#\mathcal A = \#\mu \).
\end{lemma}
\begin{proof}
    \( \#\mathcal L = \#\mu \) by \cref{lem:mk_litter}, and \( \#\aleph_0 \leq \#\kappa < \#\mu \) by \cref{def:params}.
\end{proof}
\begin{definition}
    The \cdef{BaseType/Atom}{litterSet}{litter set} of a litter \( L \) is the set of atoms with first projection equal to \( L \), denoted \( \mathcal A_L \).
\end{definition}
\begin{lemma}
    \label{lem:litterSet}
    \begin{enumerate}
        \item \( \#\mathcal A_L = \#\kappa \);
        \item the litter sets are pairwise disjoint.
    \end{enumerate}
\end{lemma}
\begin{proof}
    \begin{enumerate}
        \item Each litter set is naturally in bijection with \( \kappa \).
        \item If an atom \( a \) is in \( \mathcal A_L \) and \( \mathcal A_{L'} \), then \( \pi_1(a) = L \) and \( \pi_1(a) = L' \) so \( L = L' \).
    \end{enumerate}
\end{proof}

\subsection{Near-litters}

\begin{definition}
    A set of atoms \cdef{BaseType/NearLitter}{IsNearLitter}{is a near-litter} to a given litter \( L \) if it is near the litter set of \( L \).
\end{definition}
\begin{lemma}
    \label{lem:isNearLitter}
    \begin{enumerate}
        \item \( \mathcal A_L \) is a near-litter to \( L \);
        \item if \( s, t \) are near-litters to \( L \) then \( s \) is near \( t \);
        \item if \( s \) is a near-litter to \( L \), \( \#s = \#\kappa \);
        \item a set cannot be a near-litter to two different litters;
        \item there are \( \mu \) near-litters to a given litter.
    \end{enumerate}
\end{lemma}
\begin{proof}
    \begin{enumerate}
        \item Direct from \cref{lem:near}(i).
        \item Follows from \cref{lem:near}(iii).
        \item We have
        \[ \#s \leq \#(s \setminus \mathcal A_L) + \#(\mathcal A_L) \]
        The first term is less than \( \#\kappa \) by \cref{lem:small}(iii); the second is exactly \( \#\kappa \) by \cref{lem:litterSet}(i).
        Thus \( \#s \leq \#\kappa \).
        Suppose \( \#s < \#\kappa \).
        Note that
        \[ \#\kappa = \#\mathcal A_L \leq \#(\mathcal A_L \setminus s) + \#s \]
        But \( \#s < \#\kappa \) by assumption, and \( \#(\mathcal A_L \setminus s) < \#\kappa \) by \cref{lem:litterSet}(i).
        This gives a contradiction.
        \item First note that if \( \mathcal A_L \) is a near-litter to \( L' \), then \( L = L' \).
        Suppose \( L \neq L' \).
        Then \( \mathcal A_L \subseteq \mathcal A_L \symmdiff \mathcal A_{L'} \).
        Hence the cardinality of \( \mathcal A_L \symmdiff \mathcal A_{L'} \) is at least \( \#\kappa \), contradicting nearness.
        For general sets, if \( s \) is a near-litter to \( L \) and \( L' \), we must have that \( \mathcal A_L \) is a near-litter to \( L' \), reducing to the original case.
        \item We argue by antisymmetry.
        First, we show that the number of near-litters to \( L \) is at most \( \#\mu \).
        Note that as \( \#\mu \) is a strong limit cardinal, the type of sets (of atoms, say) of size less than the cofinality of \( \#\mu \) also has cardinality \( \#\mu \).
        But as the cofinality of \( \#\mu \) is at least \( \#\kappa \), it suffices to show an injection from the type of near-litters to \( L \) to the type of sets of atoms of size at most \( \#\kappa \), which can be done by the natural coercion.

        Conversely, we need an injection from \( \mathcal A \) to the type of near-litters to \( L \).
        The map \( a \mapsto \mathcal A_L \symmdiff \qty{a} \) suffices.
    \end{enumerate}
\end{proof}
\begin{definition}
    A \cdef{BaseType/NearLitter}{NearLitter}{near-litter} is a dependent pair \( \langle L, s \rangle \), where \( L \) is a litter and \( s \) is a set of atoms that is a near-litter to \( L \).
    We denote the type of near-litters by \( \mathcal N \).
    We define a natural injective coercion from a near-litter to its second component; this is often used in extensionality arguments.
\end{definition}
\begin{remark}
    Retaining the data of which litter a given near-litter is near to allows us to get better definitional properties.
\end{remark}
\begin{definition}
    The first projection \( \pi_1 : \mathcal N \to \mathcal L \) is written with a superscript circle: \( N \mapsto N^\circ \).
    The injection \( \symsf{NL} : \mathcal L \to \mathcal N \) is defined by \( \symsf{NL}\ L = \langle L, \mathcal A_L \rangle \), sending a litter to its \cdef{BaseType/NearLitter}{Litter.toNearLitter}{associated near-litter}.
\end{definition}
\begin{lemma}
    \label{lem:nearLitter_prop}
    Let \( N : \mathcal N \).
    Then \( N \symmdiff \mathcal A_{N^\circ} \) is small.
\end{lemma}
\begin{proof}
    Suppose \( N = \langle L, s \rangle \).
    Then \( s \) is near to \( \mathcal A_L \) as required.
\end{proof}
\begin{lemma}
    \label{lem:mk_nearLitter}
    \( \#\mathcal N = \#\mu \).
\end{lemma}
\begin{proof}
    \begin{align*}
        \#\mathcal N &= \#\sum_{(L : \mathcal L)} \qty{s : \symsf{Set}\ \mathcal A \mid s\ \symsf{near}\ \mathcal A_L} \\
        &= \sum_{(L : \mathcal L)} \#\qty{s : \symsf{Set}\ \mathcal A \mid s\ \symsf{near}\ \mathcal A_L} \\
        (\text{\cref{lem:isNearLitter}(v)}) \quad &= \sum_{(L : \mathcal L)} \#\mu \\
        &= \#\mathcal L \cdot \#\mu \\
        (\text{\cref{lem:mk_litter}}) \quad &= \#\mu \cdot \#\mu \\
        (\text{\cref{lem:infinite_no_max_model_params}}) \quad &= \#\mu
    \end{align*}
\end{proof}
\begin{lemma}
    \label{lem:mk_nearLitter''}
    Let \( N : \mathcal N \).
    Then \( \#N = \#\kappa \).
\end{lemma}
\begin{proof}
    We argue by antisymmetry that
    \[ \#(N \symmdiff \mathcal A_{N^\circ} \symmdiff \mathcal A_{N^\circ}) = \#\kappa \]
    First, we show that this is at most \( \#\kappa \).
    By monotonicity it suffices to show that
    \[ \#((N \symmdiff \mathcal A_{N^\circ}) \cup \mathcal A_{N^\circ}) \leq \#\kappa \]
    By \cref{lem:nearLitter_prop} and \cref{lem:litterSet}(i), this holds.

    Conversely, suppose \( N \symmdiff \mathcal A_{N^\circ} \symmdiff \mathcal A_{N^\circ} \) is small.
    Then as \( N \symmdiff \mathcal A_{N^\circ} \) is small, by \cref{lem:small}(vi) we must have that \( \mathcal A_{N^\circ} \) is small, which is a contradiction.
\end{proof}
\begin{lemma}
    Let \( N_1, N_2 : \mathcal N \).
    Then if \( N_1^\circ = N_2^\circ \), their intersection \( N_1 \cap N_2 \) is nonempty.
\end{lemma}
\begin{proof}
    First, note that \( N_1 \) is near \( N_2 \), so \( N_2 \setminus N_1 \) is small.
    Suppose the intersection is empty, then \( N_2 \setminus N_1 = N_2 \).
    But then \( N_2 \) would be small, contradicting \cref{lem:mk_nearLitter''}.
\end{proof}

\subsection{Near-litter permutations}

\begin{definition}
    A \cdef{BaseType/NearLitterPerm}{NearLitterPerm}{near-litter permutation} is a pair \( \pi = \langle \pi^A, \pi^L \rangle \) where \( \pi^A : \symsf{perm}\ \mathcal A \) and \( \pi^L : \symsf{perm}\ \mathcal L \), such that if \( s \) is a near-litter to \( L \), \( {\pi^A} '' s \) is a near-litter to \( \pi^L\ L \).
    Thus a near-litter permutation induces a permutation of near-litters.
    The type of near-litter permutations is denoted \( \mathcal P \).
\end{definition}
We suppress the superscripts on near-litter permutations and use function application syntax for the action of a near-litter permutation on atoms, litters, and near-litters: for example, \( \pi^A\ a = \pi\ a \).
Note that the action on litters is `rough': we map litters to litters and not near-litters.
If the precise image of a litter \( L \) under a permutation \( \pi \) is desired, it can be obtained using \( \pi(\symsf{NL}\ L) \).
\begin{lemma}
    \label{lem:NearLitterPerm.atomPerm_injective}
    If the atom permutations of two near-litter permutations agree, then the permutations are equal.
\end{lemma}
\begin{proof}
    Let \( L : \mathcal L \) and \( \pi, \pi' \) be near-litter permutations.
    The values of \( \pi\ (\symsf{NL}\ L) \) and \( \pi'\ (\symsf{NL}\ L) \) depend only on the atom maps in question.
    The result then follows from \cref{lem:isNearLitter}(iv).
\end{proof}
\begin{lemma}
    The near-litter permutations form a group with identity \( \symrm{id} \) and operation \( \circ \).
\end{lemma}
\begin{lemma}
    \label{lem:smul_nearLitter_eq_smul_symmDiff_smul}
    Let \( \pi \) be a near-litter permutation and let \( N \) be a near-litter.
    Then, the following equality of sets holds.
    \[ \pi\ N = (\pi\ (\mathsf{NL}\ N^\circ)) \symmdiff (\pi '' (\mathcal A_{N^\circ} \symmdiff N)) \]
\end{lemma}
\begin{proof}
    After applying set extensionality, this proof becomes simple case checking.
\end{proof}

\section{Tangled structure}

We now describe how the different levels of our structure are to be tangled together.

\subsection{Extended type indices}

\begin{definition}
    We define a quiver structure on type indices.
    For \( \alpha, \beta \) type indices, \( \symrm{Hom}(\alpha, \beta) \) is the type \( \beta < \alpha \).
    Thus, there is a morphism \( \alpha \to \beta \) if and only if \( \beta < \alpha \), and all such morphisms are equal by proof irrelevance.
\end{definition}
\begin{definition}
    A path from a type index to \( \bot \) is called an \cdef{Structural/Index}{ExtendedIndex}{extended (type) index}.
\end{definition}
\begin{lemma}
    \label{lem:path_props}
    \begin{enumerate}
        \item If \( A : \alpha \rightsquigarrow \beta \) is a path of type indices, \( \beta \leq \alpha \).
        \item If \( A : \alpha \rightsquigarrow \alpha \), then \( A \) is the empty path.
        \item If \( \alpha : \lambda \), then the extended index \( A : \alpha \rightsquigarrow \bot \) has nonzero length.
    \end{enumerate}
\end{lemma}
\begin{proof}
    \begin{enumerate}
        \item Induction on \( A \).
        \item If \( A \) were nonempty, it would be of the form \( B \gg h \) where \( B : \alpha \rightsquigarrow \beta \) and \( h : \beta \to \alpha \).
        By (i), \( \beta \leq \alpha \), but \( h \) is the fact that \( \alpha < \beta \), giving a contradiction.
        \item \( \alpha \neq \bot \) so \( A \) is not the empty path.
    \end{enumerate}
\end{proof}
\begin{lemma}
    \label{lem:mk_extendedIndex}
    \( 0 \neq \#(\alpha \rightsquigarrow \bot) \leq \#\lambda \).
\end{lemma}
\begin{proof}
    There is at least one extended index for each \( \alpha \): the nil path for \( \alpha = \bot \) or the one-arrow path otherwise.
    For the other inequality, \mlem{Combinatorics/Quiver/Path}{Quiver.Path.toList}{there is an injection} from paths \( \alpha \rightsquigarrow \bot \) to lists, so it suffices to show that the type of lists of type indices has cardinality at most \( \#\lambda \).
    But \( \aleph_0 \leq \#\lambda \) by \ref{lem:infinite_no_max_model_params}(i), so it suffices to show that \( \#\lambda^\bot \leq \#\lambda \), which is \ref{lem:mk_typeIndex}.
\end{proof}

\subsection{Pretangles}

Omitted; currently unused.

\subsection{Trees}

\begin{definition}
    Let \( \alpha \) be a type index and \( \tau \) be a type.
    Then the type of \cdef{Structural/Tree}{Tree}{\( \alpha \)-trees of \( \tau \)} is
    \[ \symsf{Tree}_\tau\ \alpha = (\alpha \rightsquigarrow \bot) \to \tau \]
\end{definition}
\begin{definition}
    \label{def:tree_ofBot}
    There is a natural equivalence \( \symsf{Tree}_\tau\ \bot \simeq \tau \) given by \( a \mapsto a\ \varnothing \) and \( a \mapsto (A \mapsto a) \).
\end{definition}
\begin{definition}
    Let \( \tau \) have a group structure.
    Then we endow \( \symsf{Tree}_\tau\ \alpha \) with a group structure by defining
    \[ (a_1 \cdot a_2)\ A = a_1\ A \cdot a_2\ A \]
    This makes the equivalence \( \symsf{Tree}_\tau\ \bot \simeq \tau \) into an isomorphism of groups.
\end{definition}
\begin{definition}
    \label{def:derivative}
    The \cdef{Structural/Tree}{Tree.comp}{derivative} functor maps paths of type indices \( \alpha \rightsquigarrow \beta \) to functions \( \symsf{Tree}_\tau\ \alpha \to \symsf{Tree}_\tau\ \beta \).
    Applying it to a path \( A \) and tree \( a \) gives the tree \( B \mapsto a\ (A \gg B) \).
    The application of this functor to a path \( A \) and tree \( a \) is denoted using a subscript, so
    \[ a_A = (B \mapsto a\ (A \gg B)) \]
\end{definition}
\begin{remark}
    This is a functor from the category of type indices where the morphisms are the decreasing paths (i.e.\ the category where morphisms are elements of \( \alpha \rightsquigarrow \beta \) for \( \alpha, \beta : \lambda^\bot \)) to the category of all trees of a fixed type \( \tau \), where the morphisms are functions.
    The map of objects is simply \( \alpha \mapsto \symsf{Tree}_\tau\ \alpha \), or more concisely, just \( \symsf{Tree}_\tau \).
    If \( \tau \) has a group structure, this map preserves multiplication.
    This means that we can treat this as a functor to the category of all trees on \( \tau \) where the morphisms are group homomorphisms.
\end{remark}
\begin{lemma}
    \label{lem:derivative_functor}
    The derivative map is a functor in the sense described above:
    \begin{enumerate}
        \item \( a_\varnothing = a \);
        \item \( (a_A)_B = a_{A \gg B} \);
        \item \( (a_1 \cdot a_2)_A = {a_1}_A \cdot {a_2}_A \).
    \end{enumerate}
    In addition, if \( A : \alpha \rightsquigarrow \bot \), then \( a_A \) and \( a\ A \) are equal up to the equivalence in \cref{def:tree_ofBot}.
\end{lemma}
\begin{proof}
    All of these results follow from the basic laws of quivers.
\end{proof}
\begin{definition}
    If \( \tau \) has a group action on some type \( \sigma \), we pull it back under the equivalence given in \cref{def:tree_ofBot} to give \( \symsf{Tree}_\tau\ \bot \) the same action on \( \sigma \).
\end{definition}

\subsection{Structural permutations}

\begin{definition}
    For \( \alpha \) a type index, an \cdef{Structural/StructPerm}{StructPerm}{\( \alpha \)-structural permutation} is an \( \alpha \)-tree of near-litter permutations.
    The type of \( \alpha \)-structural permutations is denoted \( \symsf{Str}_\alpha \), so
    \[ \symsf{Str}_\alpha = \symsf{Tree}_{\mathcal P}\ \alpha = (\alpha \rightsquigarrow \bot) \to \mathcal P \]
\end{definition}

\subsection{Supports and support conditions}

\begin{definition}
    For \( \alpha \) a type index, the type of \cdef{Structural/Support}{SupportCondition}{\( \alpha \)-support conditions} is
    \[ (\alpha \rightsquigarrow \bot) \times (\mathcal A \oplus \mathcal N) \]
    That is, an \( \alpha \)-support condition is an \( \alpha \)-extended type index, together with an atom or near-litter.
\end{definition}
\begin{lemma}
    \label{lem:mk_supportCondition}
    For each \( \alpha \), there are \( \#\mu \) \( \alpha \)-support conditions.
\end{lemma}
\begin{proof}
    By \cref{lem:mk_atom} and \cref{lem:mk_nearLitter}, we must show that
    \[ \#(\alpha \rightsquigarrow \bot) \cdot (\#\mu + \#\mu) = \#\mu \]
    This follows from standard properties of cardinals and \cref{lem:mk_extendedIndex}.
\end{proof}
\begin{definition}
    \( \alpha \)-structural permutations \( \pi \) act on \( \alpha \)-support conditions by mapping
    \[ \langle A, x \rangle \mapsto \langle A, \pi\ A\ x \rangle \]
    where the action of a near-litter permutation on an element of \( \mathcal A \oplus \mathcal N \) is defined in the natural way.
\end{definition}
\begin{definition}
    Let \( \alpha \) be a type index, \( \tau \) be a type, \( x : \tau \), and \( G \) be a group that acts on \( \tau \).
    A \cdef{Structural/Support}{Support}{support} for \( x \) under this action is a small set of \( \alpha \)-support conditions that support \( x \) (in the sense of \cref{def:supports}).
    An object is said to be \cdef{Structural/Support}{Supported}{supported} if its type of supports is nonempty.
\end{definition}

\section{\texorpdfstring{\( f \)}{f}-maps}

We now describe the mechanism for creating the \( f \)-maps, and begin the main recursion.

\subsection{Position functions}

\begin{definition}
    Let \( \alpha, \beta \) be types.
    A \cdef{Fuzz/Position}{Position}{position function} on \( \alpha \) taking values in \( \beta \) is an injection \( \alpha \to \beta \).
    We denote all position functions by \( n : \alpha \to \beta \).
\end{definition}
Let \( \alpha \) have a position function taking values in \( \beta \), and suppose \( \beta \) has a relation \( < \).
\begin{definition}
    We then define the relation \( < \) on \( \alpha \) by \( x < y \Leftrightarrow n\ x < n\ y \).
\end{definition}
\begin{lemma}
    If \( \beta \) is well-ordered, then \( \alpha \) is well-ordered.
\end{lemma}
\begin{proof}
    Trichotomy and transitivity are clear.
    The inverse image of a well-founded relation \corelem{Init/WF}{InvImage.wf}{is well-founded} by induction on accessibility, completing the proof.
\end{proof}

\subsection{Hypotheses}

\begin{definition}
    Let \( \alpha \) be a type index.
    \cdef{Fuzz/Hypotheses}{TangleData}{Tangle data} at level \( \alpha \) is
    \begin{itemize}
        \item a type \( \tau_\alpha \) of \emph{tangles};
        \item a type \( \symsf{All}_\alpha \) of \emph{allowable permutations};
        \item a group structure on \( \symsf{All}_\alpha \);
        \item a group homomorphism \( \symsf{All}_\alpha \to \symsf{Str}_\alpha \);
        \item a group action of \( \symsf{All}_\alpha \) on \( \tau_\alpha \) written by juxtaposition; and
        \item a function assigning to each \( t : \tau_\alpha \) a support for it under the action of \( \symsf{All}_\alpha \), called its \emph{designated support}.
    \end{itemize}
\end{definition}
\begin{definition}
    Let \( \alpha \) be a type index with tangle data.
    We say that level \( \alpha \) has \cdef{Fuzz/Hypotheses}{PositionedTangles}{positioned tangles} if there is a position function on \( \tau_\alpha \) taking values in \( \mu \).
    The existence of this position function proves that there are at most \( \#\mu \) tangles at level \( \alpha \).
\end{definition}
\begin{definition}
    Let \( \alpha : \lambda \) be a proper type index with tangle data.
    We say that we have \cdef{Fuzz/Hypotheses}{TypedObjects}{typed objects} at level \( \alpha \) if we have
    \begin{itemize}
        \item an injection \( \symsf{typed}^a_\alpha : \mathcal A \to \tau_\alpha \) called the \emph{typed atom} map; and
        \item an injection \( \symsf{typed}^N_\alpha : \mathcal N \to \tau_\alpha \) called the \emph{typed near-litter} map, that commutes with allowable permutations in the sense that for all \( \rho : \symsf{All}_\alpha, N : \mathcal N \), we have
        \[ \rho\ (\symsf{typed}^N_\alpha\ N) = \symsf{typed}^N_\alpha\ (\rho\ (\alpha \to \bot)\ N) \]
    \end{itemize}
\end{definition}
\begin{definition}
    An assignment of \cdef{Fuzz/Hypotheses}{BasePositions}{base positions} is a pair of position functions on \( \mathcal A \) and \( \mathcal N \) both taking values in \( \mu \), such that
    \begin{itemize}
        \item \( a \in \mathcal A_L \implies n\ (\symsf{NL}\ L) < n\ a \);
        \item \( n\ (\symsf{NL}\ N^\circ) \leq n\ N \);
        \item \( a \in N \symmdiff \mathcal A_{N^\circ} \implies n\ a < n\ N \);
        \item \( n\ a \neq n\ N \).
    \end{itemize}
\end{definition}
\begin{remark}
    At the moment, we define no coherence conditions between the position function, the typed objects, and the base positions data.
    Later, they will be tied together.
\end{remark}
\begin{definition}
    Tangle data at level \( \alpha = \bot \) is defined as follows.
    \begin{itemize}
        \item \( \tau_\bot = \mathcal A \);
        \item \( \symsf{All}_\bot = \mathcal P \);
        \item the homomorphism \( \symsf{All}_\bot \to \symsf{Str}_\bot \) is given by \cref{def:tree_ofBot};
        \item the designated support of an atom \( a : \mathcal A \) is \( \{\langle a, \varnothing \rangle\} \).
    \end{itemize}
\end{definition}

\subsection{Construction}

\begin{lemma}
    \label{lem:chooseWf}
    Let \( \alpha \) and \( \beta \) be types, and let \( \alpha \) be well-ordered.
    Let \( d : \alpha \to \symsf{Set}\ \beta \) assign to each \( x : \alpha \) a set of \emph{denied sets}.
    Suppose that for each \( x : \alpha \), we have
    \[ \#\{ y : \alpha \mid y < x \} + \#(d\ x) < \#\beta \]
    Then \clem{Fuzz/Construction}{chooseWf}{there is} an injective function \( f : \alpha \to \beta \) with the property that for each \( x : \alpha \), \( f\ x \not\in d\ x \).
\end{lemma}
\begin{proof}
    For a given \( x : \alpha \), if we have already constructed \( f\ y \) for \( y < x \), we can pick a value for \( f\ x \) not in \( d\ x \) or equal to any \( f\ y \), as
    \begin{align*}
        \#(f '' \{ y : \alpha \mid y < x \} \cup d\ x) &\leq \#(f '' \{ y : \alpha \mid y < x \}) + \#(d\ x) \\
        &\leq \#\{ y : \alpha \mid y < x \} + \#(d\ x) \\
        &< \#\beta
    \end{align*}
    We have thus constructed \( f : \alpha \to \beta \) satisfying the property that \( f\ x \not\in d\ x \).
    For injectivity, suppose \( x \neq y : \alpha \).
    Then either \( x < y \) or \( y < x \); assume the latter without loss of generality.
    The construction of \( f\ x \) was done under the constraint \( f\ x \neq f\ z \) for each \( z < x \), giving the result as required.
\end{proof}
Let \( \beta : \lambda^\bot \) and \( \gamma : \lambda \) with \( \beta \neq \gamma \).
Let \( \beta \) and \( \gamma \) have tangle data and positioned tangles.
Let \( \gamma \) have typed objects.
\begin{definition}
    \label{def:fuzz_deny}
    Construct the function \( d : \tau_\beta \to \symsf{Set}\ \mu \) by
    \begin{align*}
        \nu \in d\ t &\Leftrightarrow (\exists N : \mathcal N,\, N^\circ = \langle \nu, \beta, \gamma \rangle \wedge n\ (\symsf{typed}^N_\gamma\ N) \leq n\ t) \\
        &\quad\vee (\beta = \bot \wedge n\ (\symsf{typed}^N_\gamma\ (\symsf{NL}\ \langle \nu, \bot, \gamma \rangle)) \leq n\ t)
    \end{align*}
\end{definition}
\begin{lemma}
    \label{lem:mk_invImage_lt_le}
    Let \( t : \tau_\beta \).
    Then
    \begin{enumerate}
        \item \( \#\{ t' : \tau_\beta \mid t' < t \} < \#\mu \);
        \item \( \#\{ t' : \tau_\gamma \mid n\ t' \leq n\ t \} < \#\mu \).
    \end{enumerate}
\end{lemma}
\begin{proof}
    Both proofs follow the same strategy.
    First, we use \cref{lem:card_Iio_lt} to reduce to showing that
    \[ \#\{ t' : \tau_\beta \mid t' < t \} \leq \#\{ \nu : \mu \mid \nu < n\ t \} \]
    and
    \[ \#\{ t' : \tau_\gamma \mid n\ t' < n\ t \} \leq \#\{ \nu : \mu \mid \nu \leq n\ t \} \]
    These inequalities of cardinals can be easily shown by proving that the injection \( n \) has the correct codomain in each case.
\end{proof}
\begin{lemma}
    \label{lem:mk_fuzz_deny}
    Let \( t : \tau_\beta \).
    Then \( \#\{ t' : \tau_\beta \mid t' < t \} + \#(d\ t) < \#\mu \).
\end{lemma}
\begin{proof}
    By \cref{lem:mk_invImage_lt_le}(i), it suffices to show \( \#(d\ t) < \#\mu \).
    We show that there are less than \( \mu \) positions that satisfy each of the two conditions in \cref{def:fuzz_deny}.

    For the first condition, we must show that
    \[ \#\{ \nu : \mu \mid \exists N : \mathcal N,\, N^\circ = \langle \nu, \beta, \gamma \rangle \wedge n\ (\symsf{typed}^N_\gamma\ N) \leq n\ t \} < \#\mu \]
    By \cref{lem:mk_invImage_lt_le}(ii) it suffices to produce an injection
    \[ \{ \nu : \mu \mid \exists N : \mathcal N,\, N^\circ = \langle \nu, \beta, \gamma \rangle \wedge n\ (\symsf{typed}^N_\gamma\ N) \leq n\ t \} \to \{ t' : \tau_\gamma \mid n\ t' \leq n\ t \} \]
    This injection is given by mapping \( \nu \) to \( \symsf{typed}^N_\gamma\ N \) where \( N \) is chosen such that \( N^\circ = \langle \nu, \beta, \gamma \rangle \) and \( n\ (\symsf{typed}^N_\gamma\ N) \leq n\ t \).
    It can be seen that this is an injection as the typed near-litter map is injective.

    Now suppose \( \beta = \bot \).
    For the second condition, it suffices by \cref{lem:card_Iio_lt} to produce an injection
    \[ \{ \nu : \mu \mid n\ (\symsf{typed}^N_\gamma\ (\symsf{NL}\ \langle \nu, \bot, \gamma \rangle)) \leq n\ t \} \to \{ \nu : \mu \mid \nu \leq n\ t \} \]
    In this case, we map \( \nu \) to \( n\ (\symsf{typed}^N_\gamma\ (\symsf{NL}\ \langle \nu, \bot, \gamma \rangle)) \).
    This is also injective, as required.
\end{proof}
\begin{definition}
    The \cdef{Fuzz/Construction}{fuzz}{\( f \)-map} from \( \beta \) to \( \gamma \) is the function \( f_{\beta,\gamma} : \tau_\beta \to \mathcal L \) defined by
    \[ f_{\beta,\gamma}\ t = \langle g\ t, \beta, \gamma \rangle \]
    where \( g \) is chosen by applying \cref{lem:chooseWf} to \cref{def:fuzz_deny} and \cref{lem:mk_fuzz_deny}.
\end{definition}
\begin{lemma}
    \label{lem:fuzz_congr}
    Suppose \( f_{\beta,\gamma}\ t = f_{\beta',\gamma'}\ t' \).
    Then \( \beta = \beta' \) and \( \gamma = \gamma' \).
\end{lemma}
\begin{proof}
    Apply the second and third projections to \( f_{\beta,\gamma}\ t \) and \( f_{\beta',\gamma'}\ t' \).
\end{proof}
\begin{lemma}
    \( f_{\beta,\gamma} \) is injective.
\end{lemma}
\begin{proof}
    Follows from \cref{lem:chooseWf}.
\end{proof}
\begin{lemma}
    Let \( N \) be a near-litter with \( N^\circ = f_{\beta,\gamma}\ t \).
    Then \( n\ t < n\ (\symsf{typed}^N_\gamma N) \).
\end{lemma}
\begin{proof}
    Follows from \cref{lem:chooseWf} and the definition of \cref{def:fuzz_deny}.
\end{proof}
\begin{lemma}
    Let \( a \) be an atom.
    Then \( n\ a < n\ (\symsf{typed}^N_\gamma (\symsf{NL}\ (f_{\bot,\gamma}\ a))) \).
\end{lemma}
\begin{proof}
    Follows from \cref{lem:chooseWf} and the definition of \cref{def:fuzz_deny}.
\end{proof}

\end{document}
